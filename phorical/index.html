<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>barely phorical</title>

  <!-- Tufte CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tufte-css/1.8.0/tufte.min.css"/>

  <style>
    :root {
      --lh: 1.45;
      --final-indent: 34ch;    /* further right for the last line */
    }

    .pi-tufte { max-width: 70ch; margin: 0 auto; }
    .poem { line-height: var(--lh); font-size: 1.1rem; margin: 0 1rem; }
    .poem p { margin: 0.85rem 0; }

    /* 10 "lines" of whitespace before and after */
    .vspace { height: calc(10 * 1em * var(--lh)); }

    /* Bracketed block laid out like your screenshot */
    .bracketed {
      position: relative;         /* for the SVG overlay */
      --gapY: 10vh;               /* vertical spacing between bracketed lines */
      --indent1: 0ch;             /* just vibes, */
      --indent2: 8ch;             /* and slides, */
      --indent3: 16ch;            /* you know, */
      --indent4: 30ch;            /* metaphorical?* adjusted from 30 for mobile optimisation */
      display: grid;
      row-gap: var(--gapY);
      margin: 2rem 0 2rem;
    }
    .bracket-open, .bracket-close {
      font-size: 1.35rem; color: #444; user-select: none;
    }

    /* Interactive lines appear as plain text but are buttons */
    .line {
      opacity: 0; transform: translateY(-0.6em);
      will-change: transform, opacity;
      display: inline-block;
      border: 0; background: none; padding: 0; margin: 0;
      text-align: left; cursor: default; font: inherit;
    }
    .line-1 { margin-left: var(--indent1); }
    .line-2 { margin-left: var(--indent2); }
    .line-3 { margin-left: var(--indent3); }
    .line-4 { margin-left: var(--indent4); }
    .line.is-active { cursor: pointer; }
    .line[disabled] { pointer-events: none; }

    /* SVG overlay used to run true curved-text between lines */
    .slide-overlay {
      position: absolute; inset: 0; width: 100%; height: 100%;
      pointer-events: none; overflow: visible; z-index: 2;
    }

    /* After-bracket lines: hidden until click-chain finishes */
    .reveal { opacity: 0; transform: translateY(12px); will-change: transform, opacity; }

    /* Final line: smaller, further right; bloom target inside */
    .final-line {
      font-size: 0.95rem;
      margin-left: var(--final-indent);
      position: relative;
      outline: none;
      cursor: pointer; /* affordance for hover/click bloom */
    }

    /* Sidenote slightly smaller than the final line */
    .poem .sidenote { font-size: 0.9em; max-width: 22rem; }
    @media (max-width: 760px) {
      .poem .sidenote { max-width: 100%; }
      .final-line { margin-left: 0; }
    }

    /* Per-character animation spans (from yesterday's project) */
    .char { display: inline-block; will-change: transform, color; }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .line, .reveal, .bracket-close { opacity: 1; transform: none !important; }
    }
  </style>

  <!-- Libraries -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
</head>
<body>
  <article class="pi-tufte">
    <section class="poem">

      <div class="vspace" aria-hidden="true"></div>

      <p>maybe it’s all</p>

      <!-- Bracketed block with curved-text slide overlay -->
      <div class="bracketed" id="call-and-slide" aria-live="polite">
        <svg class="slide-overlay" id="slide-overlay" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>

        <div class="bracket-open" aria-hidden="true">[</div>

        <button class="line line-1" type="button"><span>just vibes,</span></button>
        <button class="line line-2" type="button" disabled><span>and slides,</span></button>
        <button class="line line-3" type="button" disabled><span>you know,</span></button>
        <button class="line line-4" type="button" disabled><span>metaphorical?*</span></button>

        <div class="bracket-close" id="bracket-close" aria-hidden="true" style="opacity:0; transform:translateY(-0.4em);">]</div>
      </div>

      <!-- After the bracket: these only activate after the chain completes -->
      <p class="reveal">*Fuck off, most days I’m just barely phorical±</p>

      <!-- Final line: the part that blooms is wrapped in .gsap-bloom (from yesterday) -->
      <p class="reveal final-line" id="final-line" tabindex="0" aria-label="± φορά — fine, I’ll carry this meta-shit (hover/click to bloom)">
        <span class="gsap-bloom">± φορά — fine, I’ll carry this meta-shit uphill, to nowhere</span>
        <label for="sn-1" class="margin-toggle sidenote-number"></label>
        <input type="checkbox" id="sn-1" class="margin-toggle"/>
        <span class="sidenote">
          <em>φορά</em> (forá): “bearing, carrying” in Greek — as in <em>metaphor</em>, to carry across.
        </span>
      </p>

      <div class="vspace" aria-hidden="true"></div>

    </section>
  </article>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    gsap.registerPlugin(ScrollTrigger);

    /* =========================
       Curved-text click chain
       ========================= */
    const wrap   = document.getElementById('call-and-slide');
    const overlay = document.getElementById('slide-overlay');
    const closeB = document.getElementById('bracket-close');
    const finalLine = document.getElementById('final-line');

    const lines  = [
      document.querySelector('.line-1'),
      document.querySelector('.line-2'),
      document.querySelector('.line-3'),
      document.querySelector('.line-4')
    ].filter(Boolean);

    const afterEls = Array.from(document.querySelectorAll('.reveal'));
    let afterEnabled = false;

    function sizeOverlay() {
      const r = wrap.getBoundingClientRect();
      overlay.setAttribute('viewBox', `0 0 ${r.width} ${r.height}`);
    }
    sizeOverlay();
    addEventListener('resize', sizeOverlay);

    // After-bracket ScrollTriggers are attached ONLY once the chain completes
    function enableAfterScroll() {
      if (afterEnabled) return;
      afterEnabled = true;

      afterEls.forEach(el => {
        gsap.fromTo(el,
          { opacity: 0, y: 12 },
          {
            opacity: 1, y: 0, duration: 0.55, ease: 'power2.out',
            scrollTrigger: { trigger: el, start: 'top 85%', once: true }
          }
        );
      });
    }

    // Auto-reveal first line on scroll-in
    if (reduce) {
      lines.forEach((el, i) => {
        el.style.opacity = i === 0 ? 1 : 0;
        el.style.transform = i === 0 ? 'none' : '';
      });
      lines[0]?.classList.add('is-active');
    } else {
      gsap.fromTo(lines[0],
        { opacity: 0, y: -14 },
        {
          opacity: 1, y: 0, duration: 0.6,
          scrollTrigger: { trigger: wrap, start: 'top 70%', once: true },
          onComplete: () => lines[0]?.classList.add('is-active')
        }
      );
    }

    // --- True curved text between lines using SVG <textPath> (as shipped before) ---
    const SVG_NS = 'http://www.w3.org/2000/svg';
    let pathCounter = 0;

    function computedFont(el) {
      const cs = getComputedStyle(el);
      return `${cs.fontStyle} ${cs.fontVariant} ${cs.fontWeight} ${cs.fontSize}/${cs.lineHeight} ${cs.fontFamily}`;
    }

    function slideTextBetween(fromEl, toEl) {
      const wrapRect = wrap.getBoundingClientRect();
      const r1 = fromEl.getBoundingClientRect();
      const r2 = toEl.getBoundingClientRect();

      const x0 = r1.left - wrapRect.left + r1.width * 0.06;
      const y0 = r1.top  - wrapRect.top  + r1.height * 0.72;
      const x1 = r2.left - wrapRect.left + r2.width * 0.06;
      const y1 = r2.top  - wrapRect.top  + r2.height * 0.72;

      const dx = x1 - x0, dy = y1 - y0;
      const c1x = x0 + dx * 0.30, c1y = y0 + dy * 0.05; // gentle ramp-out
      const c2x = x0 + dx * 0.92, c2y = y0 + dy * 1.08; // steep then flatten near landing

      const pathId = `p-${Date.now()}-${pathCounter++}`;
      const path = document.createElementNS(SVG_NS, 'path');
      path.setAttribute('id', pathId);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'none');
      path.setAttribute('d', `M${x0},${y0} C ${c1x},${c1y} ${c2x},${c2y} ${x1},${y1}`);

      const text = document.createElementNS(SVG_NS, 'text');
      const tp = document.createElementNS(SVG_NS, 'textPath');
      tp.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#${pathId}`);
      tp.setAttribute('startOffset', '0');
      tp.textContent = fromEl.textContent;

      text.setAttribute('fill', getComputedStyle(fromEl).color);
      text.style.font = computedFont(fromEl);

      overlay.appendChild(path);
      text.appendChild(tp);
      overlay.appendChild(text);

      const len = path.getTotalLength();
      const tl = gsap.timeline({
        defaults: { ease: 'power2.out' },
        onComplete: () => { text.remove(); path.remove(); }
      });

      gsap.set(fromEl, { autoAlpha: 0 });

      tl.to(tp, { attr: { startOffset: len }, duration: 0.95, ease: 'power2.inOut' })
        .to(tp, { attr: { startOffset: len * 1.03 }, duration: 0.12, ease: 'power1.out' }, '>-0.02')
        .to(tp, { attr: { startOffset: len }, duration: 0.18, ease: 'power1.inOut' }, '>-0.02')
        .add(() => gsap.set(fromEl, { autoAlpha: 1 }));

      return tl;
    }

    function chain(i) {
      const current = lines[i];
      const next    = lines[i + 1];
      if (!current || !next || current.disabled) return;

      current.disabled = true;

      const tl = gsap.timeline({ defaults: { ease: 'power2.out' } });
      tl.add(slideTextBetween(current, next))
        .fromTo(next, { opacity: 0, y: -20 }, { opacity: 1, y: 0, duration: 0.45, ease: 'back.out(1.6)' }, '-=0.30')
        .add(() => {
          current.classList.remove('is-active');
          next.disabled = false;
          next.classList.add('is-active');
        });

      if (i === lines.length - 2) {
        tl.fromTo(closeB, { opacity: 0, y: -8 }, { opacity: 1, y: 0, duration: 0.45, ease: 'power2.out' })
          .add(enableAfterScroll);
      }
    }

    lines.forEach((btn, idx) => btn.addEventListener('click', () => chain(idx)));

    /* =========================
       BLOOM (identical logic to ostende’s)
       - per-character GSAP tween
       - scale + colour, yoyo once, staggered
       ========================= */
    // Tiny in-place text splitter to wrap non-space chars in .char
    function splitCharsIn(el) {
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
        acceptNode(n) { return /\S/.test(n.nodeValue) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT; }
      });
      const nodes = [];
      while (walker.nextNode()) nodes.push(walker.currentNode);
      nodes.forEach(node => {
        const parent = node.parentElement;
        if (!parent || parent.closest('.sidenote') || parent.closest('label') || parent.closest('input')) return;
        const frag = document.createDocumentFragment();
        for (const ch of node.nodeValue) {
          if (ch === ' ') { frag.appendChild(document.createTextNode(' ')); continue; }
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = ch;
          frag.appendChild(span);
        }
        node.parentNode.replaceChild(frag, node);
      });
    }

    // Prepare the final line’s bloom span
    const bloomSpan = finalLine.querySelector('.gsap-bloom');
    if (bloomSpan) splitCharsIn(bloomSpan);

    function bloom(targetEl) {
      if (reduce || !targetEl) return;
      const chars = targetEl.querySelectorAll('.char');
      if (!chars.length) return;

      gsap.killTweensOf(chars);
      gsap.to(chars, {
        scale: 1.24,
        color: '#dd0101',      // deep red colour
        duration: 0.6,
        yoyo: true,
        repeat: 1,
        ease: 'power1.inOut',
        stagger: 0.04
      });
    }

    // Trigger bloom on hover, click, focus (as before)
    if (bloomSpan) {
      finalLine.addEventListener('pointerenter', () => bloom(bloomSpan));
      finalLine.addEventListener('focus', () => bloom(bloomSpan));
      finalLine.addEventListener('click', (e) => {
        if (e.target.closest('.sidenote') || e.target.matches('label, input')) return;
        bloom(bloomSpan);
      });
      finalLine.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); bloom(bloomSpan); }
      });
    }

    /* Reduced motion fallback */
    if (reduce) {
      lines.forEach(el => { el.style.opacity = 1; el.disabled = false; el.classList.remove('is-active'); });
      closeB.style.opacity = 1;
      enableAfterScroll();
    }
  });
  </script>

  <!-- Back link -->
  <p style="margin:0.5rem 0 1rem"><a href="../">← back to poems</a></p>
</body>
</html>
